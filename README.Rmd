---
  output: github_document
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  # out.width = "100%",
  fig.height = 3
)
```

# Multilateral <img src='man/figures/logo-v2.png' align="right" height="139" />

## Overview

The multilateral package provides one key function, that is `multilateral()`.
The user provides the necessary attributes of a dataset to calculate their choice of multilateral methods.

See vignette for further information.

For some specific index calculation methods this package has been heavily influenced by Graham White's [IndexNumR package](https://github.com/grahamjwhite/IndexNumR). 



## Installation

```{r, eval = FALSE}
devtools::install_github("MjStansfi/multilateral")

library(multilateral)
```

## Usage

```{r example,echo=TRUE,warning=FALSE,message=FALSE,error=FALSE, results='hide',fig.keep='all'}
library(multilateral)
library(ggplot2)

tpd_index <- multilateral(period = turvey$month,
                          id = turvey$commodity,
                          price = turvey$price,
                          quantity = turvey$quantity,
                          splice_method = "geomean",
                          window_length = 13,
                          index_method = "TPD")

plot <- ggplot(tpd_index$index)+geom_line(aes(x = period, y = index))+theme_bw()

print(plot)

```

## Further detail

The function returns a list object containing 

* the continuous spliced index,
* each individual windows index,
* splicing information (if applicable).

```{r further detail}
str(tpd_index) 
```


`splice_detail` gives the user a break down of how the given periods index number is made up of both a 'revision factor' (from splicing) and the latest periods movement. This can be useful for diagnostics. 

```{r splice_detail}
head(tpd_index$splice_detail)
```

Below shows one way in which you could visualise contribution of revision factor vs latest movement
```{r visualise contrib, message=FALSE}
library(dplyr)

#Period of interest
splice_detail <- tpd_index$splice_detail[period=="1973-02-28"]

#Log information to determine contribution
lwm_log <- log(splice_detail$latest_window_movement)
rf_log <- log(splice_detail$revision_factor)
sum_log <- sum(lwm_log+rf_log)

lwm_contrib <- lwm_log/sum_log
rf_contrib <- rf_log/sum_log


ggplot(mapping = aes(fill=c("Latest movement","Revision factor"),
                     y=c(lwm_contrib,rf_contrib),
                     x="1973-02-28"))+
  geom_bar(position="stack", stat="identity", width = 0.2)+
  theme_bw()+
  xlab("Date")+
  ylab("% Contribution")+
  labs(fill = "Contributor")+
  scale_fill_manual(values = c("#085c75","#d2ac2f"))


```

The `index_windows` returns all individual windows indexes before they were spliced. Below shows how you could (roughly) visualise this data
```{r windows}
library(dplyr)

#Get splice details to relevel each new index
update_factor <- tpd_index$splice_detail%>%
  mutate(update_factor  = cumprod(update_factor))%>%
  select(window_id, update_factor)


index_windows <- merge(tpd_index$index_windows,update_factor)

index_windows <-index_windows%>%mutate(updated_index = index*update_factor)
windows_plot <- ggplot(index_windows)+
  geom_line(aes(x = period, y = updated_index, group = window_id, colour = window_id))+
  theme_bw()

print(windows_plot)
```
